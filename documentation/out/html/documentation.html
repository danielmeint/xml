<html xmlns:ng="http://docbook.org/docbook-ng"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>XForms Multiclient Blackjack Documentation</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.2"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article"><div class="titlepage"><div><div><h1 class="title"><a name="d5e1"></a>XForms Multiclient Blackjack Documentation</h1></div><div><div class="author"><h3 class="author">Daniel Meint</h3><code class="email">&lt;<a class="email" href="mailto:d.meint@tum.de">d.meint@tum.de</a>&gt;</code></div></div><div><div class="author"><h3 class="author">Felix Hennerkes</h3><code class="email">&lt;<a class="email" href="mailto:ga38hom@mytum.de">ga38hom@mytum.de</a>&gt;</code></div></div><div><div class="author"><h3 class="author">Janik Schnellbach</h3><code class="email">&lt;<a class="email" href="mailto:janik.schnellbach@tum.de">janik.schnellbach@tum.de</a>&gt;</code></div></div><div><div class="author"><h3 class="author">Maximilian Karpfinger</h3><code class="email">&lt;<a class="email" href="mailto:maximilian.karpfinger@tum.de">maximilian.karpfinger@tum.de</a>&gt;</code></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#d5e17">Introduction</a></span></dt><dt><span class="section"><a href="#d5e28">Description of the case study</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e36">Card Values</a></span></dt><dt><span class="section"><a href="#d5e40">Course of a Round</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e99">Architecture</a></span></dt><dt><span class="section"><a href="#d5e110">The component model</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e112">Modeling the model</a></span></dt><dt><span class="section"><a href="#d5e143">Design decisions and discussion</a></span></dt><dt><span class="section"><a href="#d5e162">Implementing the component Model</a></span></dt><dt><span class="section"><a href="#d5e574">Implementation details, decisions and discussion</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e593">The component View</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e595">Modeling the component View</a></span></dt><dt><span class="section"><a href="#d5e692">Implementing the component View</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e702">The component Controller</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e704">Modeling the component Controller</a></span></dt><dt><span class="section"><a href="#d5e707">Implementing the component Controller</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e711">Collaboration</a></span></dt><dt><span class="section"><a href="#d5e730">Conclusions</a></span></dt><dt><span class="bibliography"><a href="#d5e734">Bibliography</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e17"></a>Introduction</h2></div></div></div><p> The so-called XStack allows us to build stable and highly performant multi-client web
            applications using only XML technologies. This paper documents the design and
            implementation of the popular casino game Blackjack as a browser-based online
            multiplayer game and thereby demonstrates the XStack's capabilities. The system was
            developed during the summer semester 2019 in the context of the practical course
                <span class="emphasis"><em>XML Technology</em></span> at the Technical University of Munich and is
            built only with the technologies and concepts introduced in the course.
            
        </p><p>The app is expected to run reasonably well in any modern browser with SVG support, but
            we strongly recommend to use a current version of <span class="emphasis"><em>Mozilla Firefox</em></span>.
            Furthermore, for server-side processing, a current version of the XML database system
            and XQuery processor <span class="emphasis"><em>BaseX</em></span> with support for the STOMP protocol is
            needed. An installation guide can be found on Github [<a class="xref" href="#BaseXHome">BaseX</a>, <a class="xref" href="#BaseXStomp">BaseXStomp</a>]. The installation manual for our blackjack application is
            part of this document.</p><p> Our application can be used by any number of users and handles multiple games played
            in simultaneously. A client can spectate a game or join as an actively participating
            player. Unlimited clients can be subscribed to a game as spectators, but only up to five
            can play on a single table, i.e. one instance of a game, at the same time.
            
        </p><p>The paper is structured as follows. The next section described the rules and
            conceptually analyses the various phases of a game of blackjack. It is followed by a
            section on the high-level architecture of our system, which is based on the
            Model-View-Controller pattern. Subsequently, three sections explain the components of an
            MVC architecture both from a modeling and technical perspective. Finally, we dedicate
            one section to reflect on the development methodologies we employed and the organization
            of the practical course.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e28"></a>Description of the case study</h2></div></div></div><p>We follow a domain-driven design approach in the implementation of the web
            application. Therefore, we want to focus on the core domain logic of blackjack in this
            section. We explain the rules of the game and describe the order of events during a
            single round of blackjack.</p><p>Globally, there are a variety of rulesets with slight differences. We seek to present
            the most universally accepted variation, commonly found in Las Vegas casinos. Up to five
                <span class="emphasis"><em>players</em></span> compete not against each other, but separately against
            the <span class="emphasis"><em>dealer</em></span>. The objective of each player is to draw cards and
            maximize the sum of their respective values (<span class="emphasis"><em>hand value</em></span>) without
            exceeding a sum of 21 (<span class="emphasis"><em>bust</em></span>).</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e36"></a>Card Values</h3></div></div></div><p>The game is played with a single deck of French playing cards. Number cards are
                worth their value, e.g. the seven of hearts is worth seven points, face cards (Jack,
                Queen, and King) are worth ten points, and an Ace can be counted as either one or
                eleven, depending on what is more favorable in a specific situation. A hand
                containing an Ace counted as eleven is referred to as a <span class="emphasis"><em>soft</em></span>
                hand because the value of the Ace will change to a one to prevent the player from
                busting if he was to draw another card and otherwise exceed 21. A card's suit is
                irrelevant in blackjack.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e40"></a>Course of a Round</h3></div></div></div><p>Blackjack is round-based and each round consists of multiple stages. We
                distinguish between the betting, playing, and evaluation phase. After the end of a
                round, the next round can be initiated by any participating player. Players can
                leave the table at any time.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e43"></a>Betting</h4></div></div></div><p>Before the actual playing begins, players place their bets. Our version uses
                    US-dollars as currency and does not limit players in the amount they want to
                    bet. It does, however, prohibit them from playing without betting at all. We
                    will refer to this stage of the game as the <span class="emphasis"><em>betting phase</em></span>
                    throughout the following sections.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e47"></a>Playing</h4></div></div></div><p> At the beginning of the <span class="emphasis"><em>playing phase</em></span>, each player is
                    dealt two cards face up. The dealer receives one exposed card that everyone can
                    see and one hidden card.</p><p>The dealer subsequently asks each player, going clockwise around the table,
                    whether they want to improve their respective hand by drawing additional cards.
                    Each player has the following options:</p><div class="figure"><a name="d5e52"></a><p class="title"><b>Figure&nbsp;1.&nbsp;Possible player decisions.</b></p><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="100%"><tr><td><img src="../../diagrams/decisions_activity.png" width="100%" alt="Possible player decisions."></td></tr></table></div></div></div><br class="figure-break"><div class="table"><a name="d5e57"></a><p class="title"><b>Table&nbsp;1.&nbsp;Playing options explained.</b></p><div class="table-contents"><table class="table" summary="Playing options explained." border="1"><colgroup><col><col><col></colgroup><tbody><tr><td><span class="emphasis"><em>Action</em></span></td><td><span class="emphasis"><em>Description</em></span></td><td><span class="emphasis"><em>Condition</em></span></td></tr><tr><td>Stand</td><td>Ends the player's turn</td><td>Always possible and automatically performed when the player
                                    busts</td></tr><tr><td>Hit</td><td>The player receives another card from the deck</td><td>Available if the player's hand value is less than 21</td></tr><tr><td>Double</td><td>The player doubles his bet and receives exactly one more card
                                    before finishing his turn</td><td>Available as the player's first action</td></tr><tr><td>Insurance</td><td>The player puts a side-bet worth half his initial bet on the
                                    outcome that the dealer has a blackjack</td><td>Available if the player's hand value is less than 21, the
                                    first card of the dealer is an Ace, and the player only has his
                                    initial two cards</td></tr></tbody></table></div></div><br class="table-break"><p>Playing double or insurance further requires the player to have a sufficient
                    balance to cover the increased bet size.</p><p>After all of the players have finished their turn, the dealer plays in a
                    predetermined manner: He draws cards as long as his hand is worth less than 17
                    points and must stand on a soft 17 or better.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e86"></a>Evaluation</h4></div></div></div><p>Once the dealer completes his turn, each player's hand gets
                        <span class="emphasis"><em>evaluated</em></span> against the dealer's hand. As described
                    above, the goal of each player is to get a hand total closer to 21 than the
                    dealer without busting. Concretely, a player wins by achieving either of the
                    following final game states: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>A value higher than dealer's without exceeding 21</p></li><li class="listitem"><p>Any value less than 21 while the dealer busts</p></li></ul></div><p> Winning players get paid even money, i.e. 1:1 on the initial
                    bet. If they win with <span class="emphasis"><em>blackjack</em></span> (hand value of 21 with two
                    cards), they receive one and a half times their bet (3:2). Furthermore, in case
                    a player has decided to place the insurance bet and the dealer has indeed
                    blackjack, this bet is paid out 2:1. A player winning a $5 insurance bet
                    receives back the $5 plus an additional $10 from the bank, for example.</p><p>If player and dealer have equal hands and did not bust, they tie, and the
                    player's bet is returned (also called <span class="emphasis"><em>push</em></span>).</p><p>In any other case, e.g. the player busting even if the dealer busts as well,
                    the player loses their bet.</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e99"></a>Architecture</h2></div></div></div><p> As our blackjack game is implemented as a web application, the basic architecture
            resembles a client-server model, where the client (front end) runs in a web browser and
            directly communicates with the server (back end). Due to the simplicity of our
            application and the utilization of XStack, we resided from using more sophisticated
            architectures, such as Client-Server-Broker or Client-Server-Dispatcher. </p><p> The server-side Business Logic and Persistency Layers are realized using the XQuery
            processor and XML database of BaseX. The content is rendered on the server-side using an
            XSLT processor. </p><p> Communication using only HTTP requests and responses is not bidirectional. The client
            can send stateless requests that are answered by the server with a response. The server
            is not able to send requests to the client, as no active connection is maintained after
            fulfilling a request. This kind of communication is sufficient in web applications where
            the business logic is only based on the actions of the client. Applications in which the
            server should be able to update the content of the client without any requests require
            full-duplex communication. Examples for such applications are chat rooms and multiplayer
            video games. Bidirectional communication can be realized using web sockets. Here, a
            Transmission Control Protocol (TCP) connection between the client and the server is
            established and maintained until the client or server closes the connection. Therefore,
            the server can send new content to the client without incoming requests until the
            connection is closed. BaseX supports Web Sockets, utilizing the Jetty's WebSocket
            servlet API. As we decided to implement a distributed version of the game, allowing
            multiple clients to play together, we made use of the WebSockets support of BaseX.
            
        </p><p> Further, our app complies with the Model View Controller (MVC) architecture to enable
            separation of concerns and increase the maintainability of the application by decoupling
            the data representation from the data access. In MVC, the system is separated into 3
            different subsystems: the model representing the data access, the view for data
            presentation and the controller as a mediator between the data presentation and access.
            Implementations of MVC can be categorized as Push and Pull variants. In the Pull
            variant, the data is retrieved by the view from the model, while in the Push variant the
            model updates the view after changes to the data. In our application, every player
            should see the current state of the game. Therefore, we chose the push variant. The
            resulting architectural structure of our web application can be seen below. </p><div class="figure"><a name="d5e105"></a><p class="title"><b>Figure&nbsp;2.&nbsp;Model of the Resulting Architecture.</b></p><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="75%"><tr><td><img src="../../diagrams/architecture_2.png" width="100%" alt="Model of the Resulting Architecture."></td></tr></table></div></div></div><br class="figure-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e110"></a>The component model</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e112"></a>Modeling the model</h3></div></div></div><p> In an MVC-architecture the model has the control of the application's logic.
                Furthermore, it is responsible to store data, for example in a database. In order to
                maintain data, several objects with unique functionality are needed. All these
                collaborating objects provide different attributes and methods. In the following,
                the data model will be described first. Thereon the design decisions will be
                discussed. The second part consists of the implementation of the game, followed by a
                discussion on implementation details and which problems were faced. </p><p> The primary database <code class="code">xforms-games</code> consists of a list of games. For
                that, a class <code class="classname">Game</code> is needed which stores all information
                about the instance of a blackjack game. A game object needs an attribute to store
                its' id and another attribute to store the current state of the game. Regarding
                    <code class="classname">Game</code> functions, their main purpose is constructing,
                initializing and resetting game objects. Because every game object also stores all
                the attending players and a dealer, the functions essentially execute operations on
                all players. In addition to the basic functions, <code class="classname">Game</code> must
                provide some function to evaluate the game. However, the logic of evaluating a
                player should be sourced to the <code class="classname">Player</code> class. Another object
                stored in a game object is the chat. </p><p> The <code class="classname">Player</code> will need some attributes to store metadata
                like name, balance, bet, and profit. Furthermore, this class has to hold a player's
                state and whether or not a player chooses to take insurance. One more object stored
                inside the player is the player's hand, which holds the cards. As to the
                    <code class="classname">Player</code> functions, contiguous to the constructors and
                setters, there will be a lot of functions that contain the game's logic. Depending
                on the game's state, a player can take several actions, which will be passed over to
                the <code class="classname">Player</code> class by the API. Alongside the playing functions,
                some helpers which provide logic for finding the next player and joining or leaving
                a game are needed. Finally, logic to evaluate a player must be integrated. </p><p> Since the players all play against the dealer, another class
                    <code class="classname">Dealer</code> is required. It does not require any attributes,
                but it must store the deck of the game and a hand object similar to the player's.
                Concerning the functions of the class, it should provide a helper function to help
                to determine a player's profit, depending on their insurance state. More logic to
                give every player two cards and also draw for the dealer will be required. </p><p> The next class we need in our model is <code class="classname">Hand</code>. On the one
                hand, this class will provide helper functions for evaluating a player's hand. On
                the other hand, it will supply some function to calculate the optimal sum of a hand.
                This is needed because the card Ace can have the value 1 and 11. </p><p> The <code class="classname">Card</code> class will provide two attributes to store a
                card's value and suit. Besides the constructor and setter functions, there will be a
                getter function that returns a card's actual value, </p><p> Inside the <code class="classname">Chat</code> class, the players' messages should be
                stored. </p><p> The last class in the model component is <code class="classname">Usr</code>
                    (<code class="classname">User</code> is a reserved namespace in BaseX). It has no
                functions other than a constructor and setters. Users are stored database
                    <span class="quote">&#8220;<span class="quote">xforms-users</span>&#8221;</span>. </p><p> The model is represented in the following class diagram. Helper functions and
                setters/getters/constructors are omitted for readability. </p><div class="figure"><a name="d5e138"></a><p class="title"><b>Figure&nbsp;3.&nbsp;Class diagrams for component Model.</b></p><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="75%"><tr><td><img src="../../diagrams/UML.png" width="100%" alt="Class diagrams for component Model."></td></tr></table></div></div></div><br class="figure-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e143"></a>Design decisions and discussion</h3></div></div></div><p>Continuing the section about the modeling of the model, all the design decisions
                will be presented and discussed.</p><p> One of the decisions was to implement a class that takes care of the players' and
                the dealer's cards because we did not like storing single card instances inside a
                player or dealer element. We came up with the <code class="classname">Hand</code> class
                which is holding cards for the players and the dealer. It has the benefit of getting
                their cards summed up value easily, as well as evaluating a player's hand. Another
                great advantage of implementing this class is that the feature <span class="quote">&#8220;<span class="quote">split</span>&#8221;</span>
                could be added to our solution without the need to change other classes. In the real
                worlds game of blackjack players can decide to split their initial hand which allows
                them to play with two hands at one time. Without the hand class, some other ideas
                would be needed to enable this feature. For example, one could add another attribute
                to the <code class="classname">Card</code> class which indicates to which hand it belongs. </p><p> Because we want to store the global balance of a player permanently, we
                introduced the <code class="classname">Usr</code> class. This way we can easily look up the
                player's highest achieved balance for the highscore list in the lobby. For every
                game a Usr joins, a new Player instance will be created with the balance of the Usr. </p><p> We choose to have the <code class="classname">Deck</code> as an extra class so that we
                can simply store all of the game's deck's cards in one single instance, instead of
                having all of the cards inside the <code class="classname">Dealer</code> or
                    <code class="classname">Game</code> object. This grants a better structure in the model
                and simplifies functionality like shuffling the deck or drawing cards. When thinking
                about extending the game, this class can be helpful for example when one wants more
                than one deck. (in some variants of blackjack, each player has a separate deck) </p><p> So why do we need <code class="classname">Dealer</code> instead of just having another
                player object? At first, both classes may not differ a lot looking at what players
                and the dealer do in a game of blackjack. However, by closer inspection, one notices
                that the dealer has a lot of differences. Starting with the attributes, a dealer
                does not need any meta information stored like a name or balance and the dealer does
                not place a bet each round either. The only resemblance is that both objects store a
                hand object. Comparing the functions of the classes, the dealer has no choices to
                make, so none of the player's functions that are needed for a player's decision are
                required. Without the <code class="classname">Dealer</code>, we would need another way to
                store the cards included in the game. Altogether a dealer object is too unequal to
                just use another player object instead. </p><p> Another question is how to deal with players that lost all their money? We
                decided that those players get set to spectating mode and can deposit more money in
                the main menu </p><p> Since we built a multiplayer game which, in principle, could be played by clients
                in distributed locations over the internet, we needed a way to let players
                communicate with each other. We therefore decided to implement a chatting feature to
                make the experience more social. Moreover, when players leave or join the game a
                small information text will be inserted into the chat so other players will know
                that someone joined/left their game. </p><p> In conclusion, our main idea while modelling the model was to prevent writing the
                same code multiple times and segregating code by its functionality. Instead of
                having a few huge classes with a big range of functions we rather wanted to have
                more but smaller classes that are not too complex. This way the model stays a lot
                more readable and it makes it more adjustable and integrating extensions easier.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e162"></a>Implementing the component Model</h3></div></div></div><p> The component model has the responsibility of holding data. Since we use an
                object-oriented approach, all implemented classes provide their own functionality
                and attributes. So each class contains data which is altogether stored in our BaseX
                database. The database also lets us query functions via <code class="code">XQuery</code> and the
                    <code class="code">XQuery-Processor</code> because of that all of the component model's
                functions are written in <code class="code">XQuery</code> and all the data is stored as
                    <code class="code">XML</code> elements. XQuery has a functional approach and was created to
                run queries on <code class="code">XML</code> databases. One of the most important concepts of the
                language are <code class="code">FLOWR-expressions</code>. The name <code class="code">FLOWR</code> contains
                the initials of <span class="quote">&#8220;<span class="quote">for-let-order-where-return</span>&#8221;</span> and can be regarded as the
                equivalent of <span class="quote">&#8220;<span class="quote">select from where</span>&#8221;</span> queries in <code class="code">SQL</code>. The
                functions need an additional parameter <code class="code">self</code> which indicates on which
                object the code should be executed to emulate object-oriented programming in
                XQuery.</p><p> Because most of the classes have setters, getters, and constructors and the
                implementation of these functions do not differ in comparison to other classes we
                don't describe the implementation for every single class. In fact, all setter
                methods return a new element by calling the constructor with alternated parameters.
                All of the constructors create <code class="code">XML</code> elements depending on the attributes
                of a class. </p><p> Beginning with <code class="classname">Game</code> class that has the following
                attributes and functions. </p><div class="table"><a name="d5e180"></a><p class="title"><b>Table&nbsp;2.&nbsp;Game attributes</b></p><div class="table-contents"><table class="table" summary="Game attributes" border="1"><colgroup><col><col><col></colgroup><tbody><tr><td><span class="emphasis"><em>Name</em></span></td><td><span class="emphasis"><em>Type</em></span></td><td><span class="emphasis"><em>Description</em></span></td></tr><tr><td>id</td><td>double</td><td>to distinguish games</td></tr><tr><td>state</td><td>string</td><td>stores the state of the game</td></tr></tbody></table></div></div><p><br class="table-break">
                </p><div class="table"><a name="d5e199"></a><p class="title"><b>Table&nbsp;3.&nbsp;Game functions</b></p><div class="table-contents"><table class="table" summary="Game functions" border="1"><colgroup><col><col><col><col></colgroup><tbody><tr><td><span class="emphasis"><em>Name</em></span></td><td><span class="emphasis"><em>Parameter</em></span></td><td><span class="emphasis"><em>Return Value</em></span></td><td><span class="emphasis"><em>Functionality</em></span></td></tr><tr><td>evaluate</td><td>caller:integer</td><td>void</td><td>sets game's state to <span class="quote">&#8220;<span class="quote">evaluated</span>&#8221;</span>, calls
                                    player:evaluate for all players, uses caller to determine what
                                    action the last player took</td></tr><tr><td>latestId</td><td>none</td><td>double ???</td><td>returns the highest id of all games in the database, needed
                                    for new games since the id always gets incremented</td></tr><tr><td>play</td><td>none</td><td>void</td><td>sets game's state to <span class="quote">&#8220;<span class="quote">playing</span>&#8221;</span>, sets all players
                                    besides the first player to inactive, the first one to active
                                    and finally calls dealer:deal</td></tr><tr><td>reset</td><td>none</td><td><code class="code">XML</code> element of game</td><td>sets game to state <span class="quote">&#8220;<span class="quote">betting</span>&#8221;</span>, basically calls
                                    the classes constructor with all the players that have a balance
                                    &gt; 0</td></tr></tbody></table></div></div><p><br class="table-break">
            </p><p>
                </p><div class="table"><a name="d5e237"></a><p class="title"><b>Table&nbsp;4.&nbsp;Player attributes</b></p><div class="table-contents"><table class="table" summary="Player attributes" border="1"><colgroup><col><col><col></colgroup><tbody><tr><td><span class="emphasis"><em>Name</em></span></td><td><span class="emphasis"><em>Type</em></span></td><td><span class="emphasis"><em>Description</em></span></td></tr><tr><td>balance</td><td>integer</td><td>store the balance of player</td></tr><tr><td>bet</td><td>integer</td><td>stores bet of a player</td></tr><tr><td>insurance</td><td>string</td><td>stores whether or not a player took insurance</td></tr><tr><td>name</td><td>string</td><td>stores name of player</td></tr><tr><td>profit</td><td>integer</td><td>stores profit of a round</td></tr><tr><td>state</td><td>string</td><td>stores state of player</td></tr></tbody></table></div></div><p><br class="table-break">
                </p><div class="table"><a name="d5e272"></a><p class="title"><b>Table&nbsp;5.&nbsp;Player functions</b></p><div class="table-contents"><table class="table" summary="Player functions" border="1"><colgroup><col><col><col><col></colgroup><tbody><tr><td>Name</td><td>Parameter</td><td>Return Value</td><td>Functionality</td></tr><tr><td>bet</td><td>bet:integer</td><td>void</td><td>updates self's bet by given parameter bet, calls
                                    player:next</td></tr><tr><td>double</td><td>none</td><td>void</td><td>updates the player's bet to two times of the amount of bet,
                                    calls game:evaluate if player is last otherwise
                                    player:next</td></tr><tr><td>draw</td><td>none</td><td>void</td><td>calls deck:drawCard and hand:addCard to add a card to the
                                    player, updates the player's hand and the deck</td></tr><tr><td>evaluate</td><td>none</td><td>void</td><td>calculates profit of player and updates self's balance
                                    accordingly, also updates user's balance accordingly</td></tr><tr><td>hit</td><td>none</td><td>void</td><td>calls helper player:draw, gives player another card and if
                                    they bust calls player:next or game:evaluate if they are the
                                    last player</td></tr><tr><td>insurance</td><td>none</td><td>void</td><td>updates self insurance to <span class="quote">&#8220;<span class="quote">true</span>&#8221;</span></td></tr><tr><td>isLast</td><td>none</td><td>boolean</td><td>determines and returns whether player is last</td></tr><tr><td>joinGame</td><td>gameId:integer, name:string</td><td>void</td><td>if it is the first player, creates a new game object with the
                                    new player, else just inserts the new player and adds an
                                    information to the chat about the player joining</td></tr><tr><td>leave</td><td>none</td><td>void</td><td>deletes self and calls player:next if self was active and
                                    there is more than one player, adds leave information to
                                    chat</td></tr><tr><td>next</td><td>none</td><td>void</td><td>sets self state to <span class="quote">&#8220;<span class="quote">inactive</span>&#8221;</span> and if there is a
                                    next player:nextPlayer to <span class="quote">&#8220;<span class="quote">active</span>&#8221;</span> else checks if
                                    game's state is <span class="quote">&#8220;<span class="quote">betting</span>&#8221;</span> then calls game:play
                                    otherwise game:evaluate </td></tr><tr><td>nextPlayer</td><td>none</td><td><code class="code">XML</code> element player</td><td>determines and returns the next player</td></tr><tr><td>stand</td><td>none</td><td>void</td><td>calls player:next</td></tr></tbody></table></div></div><p><br class="table-break">
            </p><p> The dealer has no attributes. </p><div class="table"><a name="d5e347"></a><p class="title"><b>Table&nbsp;6.&nbsp;Dealer functions</b></p><div class="table-contents"><table class="table" summary="Dealer functions" border="1"><colgroup><col><col><col><col></colgroup><tbody><tr><td><span class="emphasis"><em>Name</em></span></td><td><span class="emphasis"><em>Parameter</em></span></td><td><span class="emphasis"><em>Return Value</em></span></td><td><span class="emphasis"><em>Functionality</em></span></td></tr><tr><td>deal</td><td>none</td><td>void</td><td>firstly calls deck:drawTo17 for self, afterwards deals two
                                    cards for each player by adding cards of the deck to hand and
                                    removing them from the deck</td></tr><tr><td>evaluateInsurance</td><td>playerIsInsurance:integer,bet:double,playerWon:integer</td><td>integer</td><td>calculates a player's bonus depending on whether they have an
                                    insurance and if the dealer got a blackjack</td></tr></tbody></table></div></div><p><br class="table-break">
            </p><p> The deck class has no attributes. </p><div class="table"><a name="d5e371"></a><p class="title"><b>Table&nbsp;7.&nbsp;Deck functions</b></p><div class="table-contents"><table class="table" summary="Deck functions" border="1"><colgroup><col><col><col><col></colgroup><tbody><tr><td><span class="emphasis"><em>Name</em></span></td><td><span class="emphasis"><em>Parameter</em></span></td><td><span class="emphasis"><em>Return Value</em></span></td><td><span class="emphasis"><em>Functionality</em></span></td></tr><tr><td>drawCard</td><td>none</td><td>(<code class="code">XML</code> element card,<code class="code">XML</code> element
                                    deck)</td><td>calls deck:getCard to get the topmost card and calls
                                    deck:removeCardAtIndex to remove topmost card to return the new
                                    deck</td></tr><tr><td>drawTo17</td><td>hand:<code class="code">XML</code> element hand,deck:<code class="code">XML</code>
                                    element deck</td><td>(<code class="code">XML</code> element hand,<code class="code">XML</code> element
                                    deck)</td><td>recursively draws cards from given deck to given hand until
                                    hand's value &gt;= 17</td></tr><tr><td>removeCardAtIndex</td><td>index:integer</td><td><code class="code">XML</code> element deck</td><td>calls helper deck:removeCard that finds and removes the card
                                    at given index and returns a new deck without the card</td></tr><tr><td>shuffle</td><td>none</td><td><code class="code">XML</code> element deck</td><td>uses a random number generator to create a new deck with a
                                    random permutation of the cards</td></tr></tbody></table></div></div><p><br class="table-break">
            </p><p>
                </p><div class="table"><a name="d5e413"></a><p class="title"><b>Table&nbsp;8.&nbsp;Hand attributes</b></p><div class="table-contents"><table class="table" summary="Hand attributes" border="1"><colgroup><col><col><col></colgroup><tbody><tr><td><span class="emphasis"><em>Name</em></span></td><td><span class="emphasis"><em>Type</em></span></td><td><span class="emphasis"><em>Description</em></span></td></tr><tr><td>value</td><td>integer</td><td>stores the sum of the hand's card's value</td></tr></tbody></table></div></div><p><br class="table-break">
                </p><div class="table"><a name="d5e428"></a><p class="title"><b>Table&nbsp;9.&nbsp;Hand functions</b></p><div class="table-contents"><table class="table" summary="Hand functions" border="1"><colgroup><col><col><col><col></colgroup><tbody><tr><td><span class="emphasis"><em>Name</em></span></td><td><span class="emphasis"><em>Parameter</em></span></td><td><span class="emphasis"><em>Return Value</em></span></td><td><span class="emphasis"><em>Functionality</em></span></td></tr><tr><td>addCard</td><td>card:<code class="code">XML</code> element hand</td><td><code class="code">XML</code> element hand</td><td>adds the given card to given hand and returns new
                                    hand</td></tr><tr><td>evaluate</td><td>toBeat:integer</td><td>string</td><td>checks if player beats the dealer and returns a string
                                    accordingly</td></tr><tr><td>evaluateToInt</td><td>toBeat:integer</td><td>integer</td><td>checks if player beats the dealer and returns an integer
                                    accordingly, needed for player:evaluate</td></tr><tr><td>getOptimalSum</td><td>values:sequence of integers</td><td>integer</td><td>recursively calculates optimal sum in favor of player,
                                    replacing aces with value 1 if the sum of values &gt; 21</td></tr></tbody></table></div></div><p><br class="table-break">
            </p><p>
                </p><div class="table"><a name="d5e464"></a><p class="title"><b>Table&nbsp;10.&nbsp;Card attributes</b></p><div class="table-contents"><table class="table" summary="Card attributes" border="1"><colgroup><col><col><col></colgroup><tbody><tr><td><span class="emphasis"><em>Name</em></span></td><td><span class="emphasis"><em>Type</em></span></td><td><span class="emphasis"><em>Description</em></span></td></tr><tr><td>suit</td><td>string</td><td>stores the suit of the card</td></tr><tr><td>value</td><td>integer</td><td>stores the value of the card</td></tr></tbody></table></div></div><p><br class="table-break">
                </p><div class="table"><a name="d5e483"></a><p class="title"><b>Table&nbsp;11.&nbsp;Card functions</b></p><div class="table-contents"><table class="table" summary="Card functions" border="1"><colgroup><col><col><col><col></colgroup><tbody><tr><td><span class="emphasis"><em>Name</em></span></td><td><span class="emphasis"><em>Parameter</em></span></td><td><span class="emphasis"><em>Return Value</em></span></td><td><span class="emphasis"><em>Functionality</em></span></td></tr><tr><td>equals</td><td>card1:<code class="code">XML</code> element card,card2:<code class="code">XML</code>
                                    element deck</td><td>boolean</td><td>checks if value and suit of both cards are equal</td></tr><tr><td>getNumericalValue</td><td>none</td><td>integer</td><td>returns cards value, 10 for picture cards, 11 for
                                    Aces</td></tr></tbody></table></div></div><p><br class="table-break">
            </p><p>
                </p><div class="table"><a name="d5e509"></a><p class="title"><b>Table&nbsp;12.&nbsp;Usr attributes</b></p><div class="table-contents"><table class="table" summary="Usr attributes" border="1"><colgroup><col><col><col></colgroup><tbody><tr><td><span class="emphasis"><em>Name</em></span></td><td><span class="emphasis"><em>Type</em></span></td><td><span class="emphasis"><em>Description</em></span></td></tr><tr><td>balance</td><td>integer</td><td>store balance of user</td></tr><tr><td>highscore</td><td>integer</td><td>store the all time highest balance of user</td></tr><tr><td>name</td><td>string</td><td>stores name of user</td></tr><tr><td>password</td><td>string</td><td>stores password of user</td></tr></tbody></table></div></div><p><br class="table-break">
                </p><div class="table"><a name="d5e536"></a><p class="title"><b>Table&nbsp;13.&nbsp;Usr functions</b></p><div class="table-contents"><table class="table" summary="Usr functions" border="1"><colgroup><col><col><col><col></colgroup><tbody><tr><td><span class="emphasis"><em>Name</em></span></td><td><span class="emphasis"><em>Parameter</em></span></td><td><span class="emphasis"><em>Return Value</em></span></td><td><span class="emphasis"><em>Functionality</em></span></td></tr><tr><td>deposit</td><td>amount:integer</td><td>void</td><td>updates user's balance and replaces user's highscore with
                                    balance if balance &gt; highscore</td></tr></tbody></table></div></div><p><br class="table-break">
            </p><p> The chat has no attributes. </p><div class="table"><a name="d5e555"></a><p class="title"><b>Table&nbsp;14.&nbsp;Chat functions</b></p><div class="table-contents"><table class="table" summary="Chat functions" border="1"><colgroup><col><col><col><col></colgroup><tbody><tr><td><span class="emphasis"><em>Name</em></span></td><td><span class="emphasis"><em>Parameter</em></span></td><td><span class="emphasis"><em>Return Value</em></span></td><td><span class="emphasis"><em>Functionality</em></span></td></tr><tr><td>addMessage</td><td>self,msg:string</td><td><code class="code">XML</code> element chat</td><td>adds given message to chat and returns new chat</td></tr></tbody></table></div></div><p><br class="table-break">
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e574"></a>Implementation details, decisions and discussion</h3></div></div></div><p> While implementing the model, we faced a few problems and the
                    <span class="quote">&#8220;<span class="quote">XQuery-Update-Facility</span>&#8221;</span> because <code class="code">XQuery</code> is
                    <span class="quote">&#8220;<span class="quote">READ-ONLY</span>&#8221;</span>. In this section, some examples will be illustrated
                where we had to rethink our attempts of implementing database updating logic. Also,
                some interesting parts of our code will be discussed. </p><p> The first problem we faced was that one cannot replace the same node in one
                return statement more than one time. Because we want a comfortable game that
                requires as few inputs from the user as possible, we make functions like player:hit
                automatically call player:next when the player busted. That way the busted player
                stands and the next player can play without any further user input needed. So in our
                first attempts of implementing the dealer draw function, we ran into the mentioned
                problem because if the last player calls hit (which replaces the node of the deck)
                and busts at the same time, the dealer:draw function is called which also will try
                to replace the deck. A quick workaround was found by not updating the deck in the
                dealer draw function since after the dealer has played the round is over and we
                don't need the deck anymore. However,we decide to have the dealer draw at the
                beginning of a round to avoid running into this problem in the future. </p><p> As to the second problem, which has the same root as the first problem. Since
                player:double automatically calls game:evaluate if the player was the last one, the
                database was not updated yet so evaluate would still operate on data pre the
                player:double call. This means that the last player's bet is not doubled and their
                hand is still their initial hand. One solution to this could be to have another game
                state like <span class="quote">&#8220;<span class="quote">toEvaluate</span>&#8221;</span> after all players have played and the game is
                ready to be evaluated. However,at least one user input to have the game evaluated
                would be needed which interrupts the game flow. This problem also occurs when the
                last player busts. Our final solution is to add a parameter <code class="code">caller</code> to
                game:evaluate so that the function knows which action was just executed. In case
                that <code class="code">caller</code> equals 0 the last player decides to stand so no updates to
                the database are required. When <code class="code">caller</code> equals 1 the last player busts,
                so we need to make his profit negative. The third case is when <code class="code">caller</code>
                equals 2, this means the last player doubles so we need to add one card to their
                hand and doubling their bet before evaluating the player's hand. </p><p> For the <code class="classname">Deck</code> implementation, we decide to create a
                    <span class="quote">&#8220;<span class="quote">realistic</span>&#8221;</span> deck since we don't like the idea of generating random
                cards each time a draw occurs. Randomly generating cards would either face the
                problems of possibly having duplicate cards or needing to implement some code to
                check if a generated card already exists and repeat generating a card until it is no
                longer a duplicate. </p><p> Like mentioned before, we want a comfortable experience for the player by always
                ending one's turn automatically if they choose to double or bust. To achieve this we
                implement the function player:next, player:nextPlayer and player:isLast. Together
                these functions check if a player is the last one and help to set the next player's
                state to <span class="quote">&#8220;<span class="quote">active</span>&#8221;</span> otherwise. This can be used in both game states where
                inputs of all players is required (betting and playing). </p><p> Lastly, at the end of each round, when players are informed about their profit,
                any player can initiate the start of the next round without waiting for the other
                players. An alternative behavior that we considered was to implement a
                "Ready-Up"-functionality and, instead, wait for all currently participating clients
                to confirm that they want to proceed before starting the next round. We finally
                decided against a ready-up semantic for the following reasons: The final evaluation
                screen informs the player about his profit with only a single number, so there is no
                reason for the user to stay on this screen for a longer period of time.
                Nevertheless, we found that, with a ready-up semantic and multiple participating
                clients, we noticed that the flow of the game was constantly disrupted and players
                spent more time waiting for others to ready up than playing. Also, users that do not
                want to take part in another round can leave the table at any time during the
                betting or even the playing phase. We, therefore, found that initiating another
                round by any player was sufficient and creates a smoother experience overall.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e593"></a>The component View</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e595"></a>Modeling the component View</h3></div></div></div><p> The view within the MVC architecture is used to display different kinds of
                screens. The basic structure is divided into Lobby and Game. While the Lobby is used
                for basic interaction of administrative nature, the Game displays the actual playing
                environment. The current view, as well as the interaction of the view, is specified
                by the current path which is defined within the API controller (see Controller
                section). The following table lists all screen types with the corresponding
                information and interaction. </p><p>
                </p><div class="table"><a name="d5e599"></a><p class="title"><b>Table&nbsp;15.&nbsp;Model for View</b></p><div class="table-contents"><table class="table" summary="Model for View" border="1"><colgroup><col><col><col></colgroup><tbody><tr><td><span class="emphasis"><em>Screen</em></span></td><td><span class="emphasis"><em>Information</em></span></td><td><span class="emphasis"><em>Interaction</em></span></td></tr><tr><td>xforms-multiclient</td><td>&nbsp;</td><td><p>login</p><p>go to signup</p></td></tr><tr><td>xforms-multiclient/signup</td><td>&nbsp;</td><td><p>create</p><p>go to signin</p></td></tr><tr><td>xforms-multiclient (logged in)</td><td><p>name</p><p>balance</p></td><td><p>new game</p><p>join
                                        game</p><p>highscore</p><p>logout</p></td></tr><tr><td>xforms-multiclient/games</td><td><p>games(id, state, players)</p></td><td><p>join game</p><p>new game</p><p>go
                                        back</p><p>logout</p></td></tr><tr><td>xforms-multiclient/highscores</td><td><p>highscore(name, balance)</p></td><td><p>go back</p><p>logout</p></td></tr><tr><td>xforms-multiclient/games/[id] (join)</td><td><p>depending on game state</p></td><td><p>join</p><p>leave</p><p>chat</p></td></tr><tr><td>xforms-multiclient/games/[id] (betting)</td><td><p>balance</p><p>chat</p></td><td><p>bet</p><p>leave</p><p>chat</p></td></tr><tr><td>xforms-multiclient/games/[id] (playing)</td><td><p>cards</p><p>bets</p><p>players</p><p>balances</p><p>hand
                                        values</p><p>chat</p></td><td><p>game action(stand, hit, double,
                                        insurance)</p><p>leave</p><p>chat</p></td></tr><tr><td>xforms-multiclient/games/[id] (playing)</td><td><p>cards</p><p>bets</p><p>players</p><p>balances</p><p>hand
                                        values</p><p>result</p><p>chat</p></td><td><p>new
                                    round</p><p>leave</p><p>chat</p></td></tr></tbody></table></div></div><p><br class="table-break">
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e692"></a>Implementing the component View</h3></div></div></div><p> The corresponding XSL-files for Lobby and Game create an XHTML page to display
                the application in a Browser. As already stated before, the created page depends on
                the current path but also the current state of Game and Player. </p><p> Based on the restriction to XHTML, we frequently use HTML tags such as button,
                form, input, label, and table. In order to customize the appearance, a global
                Cascading Style Sheet (CSS) applies to all the created XHTML pages. The style.css
                file can be found in the static/css folder. We make use of different CSS features
                such as counters, advanced collectors, transitions and media queries. Through the
                media queries, we enable a responsive user experience. Depending on the screen size
                elements can either be hidden like the chat for instance or displayed with a
                different shape such as the tables. For the general layout, we apply a basic and
                minimalistic design that enables a uniform appearance across the whole application. </p><p> To enable the basic interaction, we use the submit type of the HTML buttons. On
                click, they create a GET/POST HTTP Request which in turn are handled and specified
                by the API. Within the Lobby, those buttons represent the central element. </p><p> On the starting screen, a player can either log in or register for the game. Once
                logged in, his current balance is displayed as well as the different buttons to
                create a new game, join an existing game, to see the highscore or to reset his
                balance. While the new game button will simply create a new game, the join game and
                highscore buttons lead to another screen including an HTML table with corresponding
                information. The Player can join a displayed game by clicking on the corresponding
                row. </p><p> The core element of the game is the table, which is implemented with SVG.
                Depending on the current situation, the SVG includes corresponding cards, chips, and
                labels(including player name, balance, and hand value). Our graphics are
                hierarchically structured to avoid redundancy. The graphic for a specific card (e.g.
                the seven of hearts) is a specific instance of a more general <span class="emphasis"><em>suit
                    card</em></span> (e.g. the hearts card), which in turn is based on the empty
                    <span class="emphasis"><em>base card</em></span>.</p><p>Concerning the game interaction, we implemented a dialog box placed below the
                table. A player can join the game, place bets or make context dependent actions like
                hit, stand, double or insurance. The dialog box is also used to display the results
                of a round, informing the player about his wins or losses. In the bottom left-hand
                corner, the chat is displayed. In order to display/hide the chat window, an
                intuitive toggle mechanism was implemented. In the top left-hand corner, a player
                always has the ability to leave the game and to go back to the lobby. </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e702"></a>The component Controller</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e704"></a>Modeling the component Controller</h3></div></div></div><p> The controller has the task to mediate between the data representation (view) and
                the data access (model). Therefore, the controller has to handle all requests of the
                view concerning the game, but also the establishment and teardown of the connection.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e707"></a>Implementing the component Controller</h3></div></div></div><p> Possible requests from the client are: menu, signup, login, logout, setup, games,
                highscore, delete, join, leave, draw, bet, hit, stand, double, insurance, new round
                and chat. These are either forwarded directly to the model or answered with static
                Html files. The requests menu, signup, login, logout, highscore are used for the
                account control and the displaying of the highscores. The remaining requests are
                used to implement the game functionalities, including the group chat. </p><p>
                
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e711"></a>Collaboration</h2></div></div></div><p> The implementation of the web application was done as a group project with a group
            size of 4. Git was used as a distributed version control system. Further, the Github
            Issues feature was used to track and assign tasks and problems. Different branches were
            utilized to test different possible implementations. </p><p> Regular meetings in person at the Informatik Faculty of the TUM and Voice over IP
            chats (TS3) were arranged using the messenger whats app regularly to coordinate the
            collaboration and progress. Visualizations of git concerning the issues and commits can
            be seen below. </p><div class="figure"><a name="d5e715"></a><p class="title"><b>Figure&nbsp;4.&nbsp;Git Overview (Master).</b></p><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="50%"><tr><td><img src="../../diagrams/pulse.png" width="100%" alt="Git Overview (Master)."></td></tr></table></div></div></div><br class="figure-break"><div class="figure"><a name="d5e720"></a><p class="title"><b>Figure&nbsp;5.&nbsp;Code Frequencey (Master).</b></p><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="50%"><tr><td><img src="../../diagrams/code_freq.png" width="100%" alt="Code Frequencey (Master)."></td></tr></table></div></div></div><br class="figure-break"><div class="figure"><a name="d5e725"></a><p class="title"><b>Figure&nbsp;6.&nbsp;Contributions (Master).</b></p><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="50%"><tr><td><img src="../../diagrams/contributions.png" width="100%" alt="Contributions (Master)."></td></tr></table></div></div></div><br class="figure-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e730"></a>Conclusions</h2></div></div></div><p> We have described the implementation of a multi-client capable web application using
            XStack technologies. Starting from a domain model of the game blackjack, we used a
            domain-driven design approach to convert our conceptual model into a functional
            programm. </p><p> Possible next steps for this project would be the deployment of the system to the
            public internet and the integration of different or more extensive rule sets, e.g. the
            implementation of the described split move available in some variants of
            blackjack.</p></div><div class="bibliography"><div class="titlepage"><div><div><h2 class="title"><a name="d5e734"></a>Bibliography</h2></div></div></div><div class="biblioentry"><a name="BaseXHome"></a><p>[BaseX] <span class="bibliomisc">BaseX homepage. http://basex.org. Last accessed on 2019 June 16
            . </span></p></div><div class="biblioentry"><a name="BaseXStomp"></a><p>[BaseXStomp] <span class="bibliomisc">BaseX with STOMP support, main repository.
                https://github.com/BaseXdb/basex/tree/stomp. Last accessed on 2019 August 8
            . </span></p></div></div></div></body></html>